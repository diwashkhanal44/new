// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'MetalForexModel.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

MetalForexModel _$MetalForexModelFromJson(Map<String, dynamic> json) {
  return _MetalForexModel.fromJson(json);
}

/// @nodoc
class _$MetalForexModelTearOff {
  const _$MetalForexModelTearOff();

  _MetalForexModel call(
      {required int? id,
      required DateTime? date,
      required Data? data,
      required String? source_name,
      required String? source_url,
      required DateTime? created_at,
      required DateTime? updated_at,
      required DateTime? deleted_at}) {
    return _MetalForexModel(
      id: id,
      date: date,
      data: data,
      source_name: source_name,
      source_url: source_url,
      created_at: created_at,
      updated_at: updated_at,
      deleted_at: deleted_at,
    );
  }

  MetalForexModel fromJson(Map<String, Object> json) {
    return MetalForexModel.fromJson(json);
  }
}

/// @nodoc
const $MetalForexModel = _$MetalForexModelTearOff();

/// @nodoc
mixin _$MetalForexModel {
  int? get id => throw _privateConstructorUsedError;
  DateTime? get date => throw _privateConstructorUsedError;
  Data? get data => throw _privateConstructorUsedError;
  String? get source_name => throw _privateConstructorUsedError;
  String? get source_url => throw _privateConstructorUsedError;
  DateTime? get created_at => throw _privateConstructorUsedError;
  DateTime? get updated_at => throw _privateConstructorUsedError;
  DateTime? get deleted_at => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MetalForexModelCopyWith<MetalForexModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetalForexModelCopyWith<$Res> {
  factory $MetalForexModelCopyWith(
          MetalForexModel value, $Res Function(MetalForexModel) then) =
      _$MetalForexModelCopyWithImpl<$Res>;
  $Res call(
      {int? id,
      DateTime? date,
      Data? data,
      String? source_name,
      String? source_url,
      DateTime? created_at,
      DateTime? updated_at,
      DateTime? deleted_at});

  $DataCopyWith<$Res>? get data;
}

/// @nodoc
class _$MetalForexModelCopyWithImpl<$Res>
    implements $MetalForexModelCopyWith<$Res> {
  _$MetalForexModelCopyWithImpl(this._value, this._then);

  final MetalForexModel _value;
  // ignore: unused_field
  final $Res Function(MetalForexModel) _then;

  @override
  $Res call({
    Object? id = freezed,
    Object? date = freezed,
    Object? data = freezed,
    Object? source_name = freezed,
    Object? source_url = freezed,
    Object? created_at = freezed,
    Object? updated_at = freezed,
    Object? deleted_at = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as Data?,
      source_name: source_name == freezed
          ? _value.source_name
          : source_name // ignore: cast_nullable_to_non_nullable
              as String?,
      source_url: source_url == freezed
          ? _value.source_url
          : source_url // ignore: cast_nullable_to_non_nullable
              as String?,
      created_at: created_at == freezed
          ? _value.created_at
          : created_at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updated_at: updated_at == freezed
          ? _value.updated_at
          : updated_at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deleted_at: deleted_at == freezed
          ? _value.deleted_at
          : deleted_at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  @override
  $DataCopyWith<$Res>? get data {
    if (_value.data == null) {
      return null;
    }

    return $DataCopyWith<$Res>(_value.data!, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc
abstract class _$MetalForexModelCopyWith<$Res>
    implements $MetalForexModelCopyWith<$Res> {
  factory _$MetalForexModelCopyWith(
          _MetalForexModel value, $Res Function(_MetalForexModel) then) =
      __$MetalForexModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {int? id,
      DateTime? date,
      Data? data,
      String? source_name,
      String? source_url,
      DateTime? created_at,
      DateTime? updated_at,
      DateTime? deleted_at});

  @override
  $DataCopyWith<$Res>? get data;
}

/// @nodoc
class __$MetalForexModelCopyWithImpl<$Res>
    extends _$MetalForexModelCopyWithImpl<$Res>
    implements _$MetalForexModelCopyWith<$Res> {
  __$MetalForexModelCopyWithImpl(
      _MetalForexModel _value, $Res Function(_MetalForexModel) _then)
      : super(_value, (v) => _then(v as _MetalForexModel));

  @override
  _MetalForexModel get _value => super._value as _MetalForexModel;

  @override
  $Res call({
    Object? id = freezed,
    Object? date = freezed,
    Object? data = freezed,
    Object? source_name = freezed,
    Object? source_url = freezed,
    Object? created_at = freezed,
    Object? updated_at = freezed,
    Object? deleted_at = freezed,
  }) {
    return _then(_MetalForexModel(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as Data?,
      source_name: source_name == freezed
          ? _value.source_name
          : source_name // ignore: cast_nullable_to_non_nullable
              as String?,
      source_url: source_url == freezed
          ? _value.source_url
          : source_url // ignore: cast_nullable_to_non_nullable
              as String?,
      created_at: created_at == freezed
          ? _value.created_at
          : created_at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updated_at: updated_at == freezed
          ? _value.updated_at
          : updated_at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deleted_at: deleted_at == freezed
          ? _value.deleted_at
          : deleted_at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MetalForexModel implements _MetalForexModel {
  const _$_MetalForexModel(
      {required this.id,
      required this.date,
      required this.data,
      required this.source_name,
      required this.source_url,
      required this.created_at,
      required this.updated_at,
      required this.deleted_at});

  factory _$_MetalForexModel.fromJson(Map<String, dynamic> json) =>
      _$_$_MetalForexModelFromJson(json);

  @override
  final int? id;
  @override
  final DateTime? date;
  @override
  final Data? data;
  @override
  final String? source_name;
  @override
  final String? source_url;
  @override
  final DateTime? created_at;
  @override
  final DateTime? updated_at;
  @override
  final DateTime? deleted_at;

  @override
  String toString() {
    return 'MetalForexModel(id: $id, date: $date, data: $data, source_name: $source_name, source_url: $source_url, created_at: $created_at, updated_at: $updated_at, deleted_at: $deleted_at)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MetalForexModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.source_name, source_name) ||
                const DeepCollectionEquality()
                    .equals(other.source_name, source_name)) &&
            (identical(other.source_url, source_url) ||
                const DeepCollectionEquality()
                    .equals(other.source_url, source_url)) &&
            (identical(other.created_at, created_at) ||
                const DeepCollectionEquality()
                    .equals(other.created_at, created_at)) &&
            (identical(other.updated_at, updated_at) ||
                const DeepCollectionEquality()
                    .equals(other.updated_at, updated_at)) &&
            (identical(other.deleted_at, deleted_at) ||
                const DeepCollectionEquality()
                    .equals(other.deleted_at, deleted_at)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(source_name) ^
      const DeepCollectionEquality().hash(source_url) ^
      const DeepCollectionEquality().hash(created_at) ^
      const DeepCollectionEquality().hash(updated_at) ^
      const DeepCollectionEquality().hash(deleted_at);

  @JsonKey(ignore: true)
  @override
  _$MetalForexModelCopyWith<_MetalForexModel> get copyWith =>
      __$MetalForexModelCopyWithImpl<_MetalForexModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MetalForexModelToJson(this);
  }
}

abstract class _MetalForexModel implements MetalForexModel {
  const factory _MetalForexModel(
      {required int? id,
      required DateTime? date,
      required Data? data,
      required String? source_name,
      required String? source_url,
      required DateTime? created_at,
      required DateTime? updated_at,
      required DateTime? deleted_at}) = _$_MetalForexModel;

  factory _MetalForexModel.fromJson(Map<String, dynamic> json) =
      _$_MetalForexModel.fromJson;

  @override
  int? get id => throw _privateConstructorUsedError;
  @override
  DateTime? get date => throw _privateConstructorUsedError;
  @override
  Data? get data => throw _privateConstructorUsedError;
  @override
  String? get source_name => throw _privateConstructorUsedError;
  @override
  String? get source_url => throw _privateConstructorUsedError;
  @override
  DateTime? get created_at => throw _privateConstructorUsedError;
  @override
  DateTime? get updated_at => throw _privateConstructorUsedError;
  @override
  DateTime? get deleted_at => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$MetalForexModelCopyWith<_MetalForexModel> get copyWith =>
      throw _privateConstructorUsedError;
}

Data _$DataFromJson(Map<String, dynamic> json) {
  return _Data.fromJson(json);
}

/// @nodoc
class _$DataTearOff {
  const _$DataTearOff();

  _Data call({required Gram? gram, required Gram? tola}) {
    return _Data(
      gram: gram,
      tola: tola,
    );
  }

  Data fromJson(Map<String, Object> json) {
    return Data.fromJson(json);
  }
}

/// @nodoc
const $Data = _$DataTearOff();

/// @nodoc
mixin _$Data {
  Gram? get gram => throw _privateConstructorUsedError;
  Gram? get tola => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DataCopyWith<Data> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataCopyWith<$Res> {
  factory $DataCopyWith(Data value, $Res Function(Data) then) =
      _$DataCopyWithImpl<$Res>;
  $Res call({Gram? gram, Gram? tola});

  $GramCopyWith<$Res>? get gram;
  $GramCopyWith<$Res>? get tola;
}

/// @nodoc
class _$DataCopyWithImpl<$Res> implements $DataCopyWith<$Res> {
  _$DataCopyWithImpl(this._value, this._then);

  final Data _value;
  // ignore: unused_field
  final $Res Function(Data) _then;

  @override
  $Res call({
    Object? gram = freezed,
    Object? tola = freezed,
  }) {
    return _then(_value.copyWith(
      gram: gram == freezed
          ? _value.gram
          : gram // ignore: cast_nullable_to_non_nullable
              as Gram?,
      tola: tola == freezed
          ? _value.tola
          : tola // ignore: cast_nullable_to_non_nullable
              as Gram?,
    ));
  }

  @override
  $GramCopyWith<$Res>? get gram {
    if (_value.gram == null) {
      return null;
    }

    return $GramCopyWith<$Res>(_value.gram!, (value) {
      return _then(_value.copyWith(gram: value));
    });
  }

  @override
  $GramCopyWith<$Res>? get tola {
    if (_value.tola == null) {
      return null;
    }

    return $GramCopyWith<$Res>(_value.tola!, (value) {
      return _then(_value.copyWith(tola: value));
    });
  }
}

/// @nodoc
abstract class _$DataCopyWith<$Res> implements $DataCopyWith<$Res> {
  factory _$DataCopyWith(_Data value, $Res Function(_Data) then) =
      __$DataCopyWithImpl<$Res>;
  @override
  $Res call({Gram? gram, Gram? tola});

  @override
  $GramCopyWith<$Res>? get gram;
  @override
  $GramCopyWith<$Res>? get tola;
}

/// @nodoc
class __$DataCopyWithImpl<$Res> extends _$DataCopyWithImpl<$Res>
    implements _$DataCopyWith<$Res> {
  __$DataCopyWithImpl(_Data _value, $Res Function(_Data) _then)
      : super(_value, (v) => _then(v as _Data));

  @override
  _Data get _value => super._value as _Data;

  @override
  $Res call({
    Object? gram = freezed,
    Object? tola = freezed,
  }) {
    return _then(_Data(
      gram: gram == freezed
          ? _value.gram
          : gram // ignore: cast_nullable_to_non_nullable
              as Gram?,
      tola: tola == freezed
          ? _value.tola
          : tola // ignore: cast_nullable_to_non_nullable
              as Gram?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Data implements _Data {
  const _$_Data({required this.gram, required this.tola});

  factory _$_Data.fromJson(Map<String, dynamic> json) =>
      _$_$_DataFromJson(json);

  @override
  final Gram? gram;
  @override
  final Gram? tola;

  @override
  String toString() {
    return 'Data(gram: $gram, tola: $tola)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Data &&
            (identical(other.gram, gram) ||
                const DeepCollectionEquality().equals(other.gram, gram)) &&
            (identical(other.tola, tola) ||
                const DeepCollectionEquality().equals(other.tola, tola)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(gram) ^
      const DeepCollectionEquality().hash(tola);

  @JsonKey(ignore: true)
  @override
  _$DataCopyWith<_Data> get copyWith =>
      __$DataCopyWithImpl<_Data>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DataToJson(this);
  }
}

abstract class _Data implements Data {
  const factory _Data({required Gram? gram, required Gram? tola}) = _$_Data;

  factory _Data.fromJson(Map<String, dynamic> json) = _$_Data.fromJson;

  @override
  Gram? get gram => throw _privateConstructorUsedError;
  @override
  Gram? get tola => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$DataCopyWith<_Data> get copyWith => throw _privateConstructorUsedError;
}

Gram _$GramFromJson(Map<String, dynamic> json) {
  return _Gram.fromJson(json);
}

/// @nodoc
class _$GramTearOff {
  const _$GramTearOff();

  _Gram call(
      {required String? silver,
      required String? finegold,
      required String? tejabigold}) {
    return _Gram(
      silver: silver,
      finegold: finegold,
      tejabigold: tejabigold,
    );
  }

  Gram fromJson(Map<String, Object> json) {
    return Gram.fromJson(json);
  }
}

/// @nodoc
const $Gram = _$GramTearOff();

/// @nodoc
mixin _$Gram {
  String? get silver => throw _privateConstructorUsedError;
  String? get finegold => throw _privateConstructorUsedError;
  String? get tejabigold => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GramCopyWith<Gram> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GramCopyWith<$Res> {
  factory $GramCopyWith(Gram value, $Res Function(Gram) then) =
      _$GramCopyWithImpl<$Res>;
  $Res call({String? silver, String? finegold, String? tejabigold});
}

/// @nodoc
class _$GramCopyWithImpl<$Res> implements $GramCopyWith<$Res> {
  _$GramCopyWithImpl(this._value, this._then);

  final Gram _value;
  // ignore: unused_field
  final $Res Function(Gram) _then;

  @override
  $Res call({
    Object? silver = freezed,
    Object? finegold = freezed,
    Object? tejabigold = freezed,
  }) {
    return _then(_value.copyWith(
      silver: silver == freezed
          ? _value.silver
          : silver // ignore: cast_nullable_to_non_nullable
              as String?,
      finegold: finegold == freezed
          ? _value.finegold
          : finegold // ignore: cast_nullable_to_non_nullable
              as String?,
      tejabigold: tejabigold == freezed
          ? _value.tejabigold
          : tejabigold // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$GramCopyWith<$Res> implements $GramCopyWith<$Res> {
  factory _$GramCopyWith(_Gram value, $Res Function(_Gram) then) =
      __$GramCopyWithImpl<$Res>;
  @override
  $Res call({String? silver, String? finegold, String? tejabigold});
}

/// @nodoc
class __$GramCopyWithImpl<$Res> extends _$GramCopyWithImpl<$Res>
    implements _$GramCopyWith<$Res> {
  __$GramCopyWithImpl(_Gram _value, $Res Function(_Gram) _then)
      : super(_value, (v) => _then(v as _Gram));

  @override
  _Gram get _value => super._value as _Gram;

  @override
  $Res call({
    Object? silver = freezed,
    Object? finegold = freezed,
    Object? tejabigold = freezed,
  }) {
    return _then(_Gram(
      silver: silver == freezed
          ? _value.silver
          : silver // ignore: cast_nullable_to_non_nullable
              as String?,
      finegold: finegold == freezed
          ? _value.finegold
          : finegold // ignore: cast_nullable_to_non_nullable
              as String?,
      tejabigold: tejabigold == freezed
          ? _value.tejabigold
          : tejabigold // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Gram implements _Gram {
  const _$_Gram(
      {required this.silver, required this.finegold, required this.tejabigold});

  factory _$_Gram.fromJson(Map<String, dynamic> json) =>
      _$_$_GramFromJson(json);

  @override
  final String? silver;
  @override
  final String? finegold;
  @override
  final String? tejabigold;

  @override
  String toString() {
    return 'Gram(silver: $silver, finegold: $finegold, tejabigold: $tejabigold)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Gram &&
            (identical(other.silver, silver) ||
                const DeepCollectionEquality().equals(other.silver, silver)) &&
            (identical(other.finegold, finegold) ||
                const DeepCollectionEquality()
                    .equals(other.finegold, finegold)) &&
            (identical(other.tejabigold, tejabigold) ||
                const DeepCollectionEquality()
                    .equals(other.tejabigold, tejabigold)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(silver) ^
      const DeepCollectionEquality().hash(finegold) ^
      const DeepCollectionEquality().hash(tejabigold);

  @JsonKey(ignore: true)
  @override
  _$GramCopyWith<_Gram> get copyWith =>
      __$GramCopyWithImpl<_Gram>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_GramToJson(this);
  }
}

abstract class _Gram implements Gram {
  const factory _Gram(
      {required String? silver,
      required String? finegold,
      required String? tejabigold}) = _$_Gram;

  factory _Gram.fromJson(Map<String, dynamic> json) = _$_Gram.fromJson;

  @override
  String? get silver => throw _privateConstructorUsedError;
  @override
  String? get finegold => throw _privateConstructorUsedError;
  @override
  String? get tejabigold => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$GramCopyWith<_Gram> get copyWith => throw _privateConstructorUsedError;
}
